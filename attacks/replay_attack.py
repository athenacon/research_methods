import torch.nn as nn
import torch
import torchvision
import pandas as pd
from sklearn.model_selection import train_test_split
import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# def replay_attack(data, cols_to_attack):
#     """
#     Implements a replay attack on specified columns of a given dataset.
#
#     Args:
#         data (pandas.DataFrame): The input dataset to be attacked.
#         cols_to_attack (list): A list of column names specifying the columns to be attacked.
#
#     Returns:
#         pandas.DataFrame: The attacked dataset.
#
#     Notes:
#         - The function creates a copy of the original dataset to store the attacked data.
#         - The attacked data is generated by replaying a portion of the original data in the specified columns.
#         - The replayed portion is randomly selected from the first half of the dataset.
#         - The proportion of rows to be replayed is randomly determined between 35% and 40%.
#         - The original dataset is not modified during the replay attack.
#     """
#
#     # Make a copy of the data
#     new_data = data.copy()
#
#     # Calculate the middle row of the data
#     middle_row = len(data) // 2
#
#     # Select a random percentage between 10-40%
#     replay_percentage = np.random.randint(35, 41) / 100
#
#     # Calculate the number of rows to replay
#     num_rows_to_replay = int(replay_percentage * len(data))
#
#     # Randomly select a start row for replay from the first half of the data
#     replay_start_row = np.random.randint(0, middle_row)
#
#     # Calculate the end row for the replay
#     replay_end_row = replay_start_row + num_rows_to_replay
#
#     for col in cols_to_attack:
#         # Extract the replay slice from the data
#         replay_slice = data.loc[replay_start_row:replay_end_row, col]
#         print("ss")
#         # Create the first part of the new data (without the replay attack)
#         new_data.loc[:replay_end_row, col] = data.loc[:replay_end_row, col]
#
#         # Index for new data
#         new_data_index = replay_end_row
#         print("sss")
#         # Loop until the new data is filled with the replay slice
#         # while new_data_index < len(data):
#         while new_data_index < 25:
#
#             print("ssss")
#             # If appending the whole replay slice will exceed the length of the original data,
#             # then truncate the replay slice
#             if new_data_index + len(replay_slice) > len(data):
#                 print("sssss")
#                 remaining_rows = len(data) - new_data_index
#                 replay_slice = replay_slice.iloc[:remaining_rows]
#
#             # Append the replay slice to the new data
#             new_data.loc[new_data_index:new_data_index+len(replay_slice)-1, col] = replay_slice.values
#
#             # Update new data index
#             new_data_index += len(replay_slice)
#     print("s")
#     return new_data
def replay_attack(data, cols_to_attack, replay_percentage):
    """
    Implements a replay attack on specified columns of a given dataset.

    Args:
        data (pandas.DataFrame): The input dataset to be attacked.
        cols_to_attack (list): A list of column names specifying the columns to be attacked.

    Returns:
        pandas.DataFrame: The attacked dataset.

    Notes:
        - The function creates a copy of the original dataset to store the attacked data.
        - The attacked data is generated by replaying a portion of the original data in the specified columns.
        - The replayed portion is randomly selected from the first half of the dataset.
        - The proportion of rows to be replayed is randomly determined between 35% and 40%.
        - The original dataset is not modified during the replay attack.
    """

    # Make a copy of the data
    new_data = data.copy()
    
    # Select a random percentage between 35-40%
    # replay_percentage = np.random.randint(35, 41) / 100

    # Calculate the number of rows to replay
    num_rows_to_replay = int(replay_percentage * len(data))

    # Randomly select a start row for replay from the first half of the data
    replay_start_row = 0

    # Calculate the end row for the replay
    replay_end_row = replay_start_row + num_rows_to_replay

    # Define replay slice for all columns to attack
    replay_slice = data.iloc[replay_start_row:replay_end_row, data.columns.get_indexer(cols_to_attack)]

    # Add the replay slice to the new data multiple times until we reach the end of the DataFrame
    for idx in range(replay_end_row, len(data), num_rows_to_replay):
        # If adding the whole replay slice would exceed the DataFrame length, trim it
        if idx + num_rows_to_replay > len(data):
            remaining_rows = len(data) - idx
            replay_slice = replay_slice.iloc[:remaining_rows, :]

        # Add the replay slice
        new_data.iloc[idx:idx + num_rows_to_replay, new_data.columns.get_indexer(cols_to_attack)] = replay_slice.values

    return new_data


